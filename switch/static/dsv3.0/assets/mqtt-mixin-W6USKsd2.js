import{P as c}from"./paho-mqtt-CBfrIYbz.js";function r(){console.log("onConnect");for(var i=window.MQTTclient.p_registers,e=i.length-1;e>=0;e--){const s=i[e];var n=s.element,t=s.channel;window.MQTTclient.client.subscribe(t),window.MQTTclient.registers[t]||(window.MQTTclient.registers[t]=[]),console.info("Subscribed to "+t+" for "+n),window.MQTTclient.registers[t].push(n)}}function l(){console.log("onConnectFailure")}class T{setUp(){const e=this;if(window.MQTTclient)return;const n=window.location.hostname,t=443,s="/ws",w="myclientid_"+parseInt(Math.random()*1e4,10),o=new c.MQTT.Client(n,t,s,w);return e.options={timeout:3,useSSL:!0,cleanSession:!0,userName:"guest",password:"guest",onSuccess:r,onFailure:l},window.MQTTclient={},window.MQTTclient.client=o,window.MQTTclient.registers={},window.MQTTclient.p_registers=[],o.onConnectionLost=e._onConnectionLost,o.onMessageArrived=e._onMessageArrived,this._connect(),this.client}_connect(){}disconnect(){window.MQTTclient.client.disconnect()}_onConnectionLost(e){console.log(e),console.log("onConnectionLost:"+e.errorMessage),window.MQTTclient.client.connect({timeout:3,useSSL:!0,cleanSession:!0,userName:"guest",password:"guest",onSuccess:r,onFailure:l})}_onMessageArrived(e){console.log("onMessageArrived"),console.log(e);var n=window.MQTTclient.registers[e.destinationName];n?n.forEach(function(t){t.onMqttMessage(e)}):console.error("message from un-subscribed channel: "+e.destinationName)}publish(e,n){var t=new c.MQTT.Message(e);t.destinationName=n,this.client.send(t)}subscribe(e){this.client.subscribe(e),alert("Subscribed")}_register(e,n){window.MQTTclient.client.subscribe(n),window.MQTTclient.registers[n]||(window.MQTTclient.registers[n]=[]),console.info("Subscribed to "+n+" for "+e),window.MQTTclient.registers[n].push(e)}register(e,n){window.MQTTclient.client.isConnected()?this._register(e,n):window.MQTTclient.p_registers.push({channel:n,element:e})}registerG(e){window.MQTTclient.registers[window.MQTTclient.unique_session_channel]||(window.MQTTclient.registers[window.MQTTclient.unique_session_channel]=[]),window.MQTTclient.registers[window.MQTTclient.unique_session_channel].push(e)}connect(){console.log(JSON.stringify(this.options)),this.client.connect(this.options)}}const u=i=>class extends i{constructor(){super();const e=new T;e.setUp(),this.mqtt=e}static get properties(){return{mqtt:Object}}register(e,n){window.MQTTclient.client.isConnected()?this.mqtt._register(e,n):window.MQTTclient.p_registers.push({channel:n,element:e})}onMqttMessage(e){}};export{u as m};
